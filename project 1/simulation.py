# -*- coding: utf-8 -*-
"""Untitled0.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1r4-uEg9OuPPxY2L0sgYERqoMe0l_shlG

Name: Hatice Nur Ağba

Student Id: 110510039

***These codes and comments are written in colab, python is used and matplotlib, random and statistics libraries are used***

**Action 1: You are supposed to write a code (in MATLAB or Python) that simulates 1000 dice rolled at the same time. The code should allow you to run several times (what you have selected beforehand), and you should show the histogram (PMF) of this discrete random variable (RV), and indicate the expected value, standard deviation, and the variance of that RV simultaneously on the screen for each run.**

In this code, program execution determines how many times the code will be executed. In this experiment that we roll dice 1000 times, we get expected value generally between 3.4 - 3.6 while the expected value for rolling a dice is 3.5 theorotically. I executed code many times and I observed that difference between probability of random variables is at most 0.03. When I increase the roll number, this deviation is even much less.
"""

import matplotlib.pyplot as plt
import random
import statistics 




programExecution = 1
rvList = []
for j in range(0, programExecution):
    rollNumber = 1000
    for i in range(0,rollNumber):
         x = random.randint(1,6)
         rvList.append(x)

standartDeviation = statistics.stdev(rvList)
variance = statistics.variance(rvList)
expectedValue = statistics.mean(rvList)


rvRange = range(min(rvList), max(rvList) + 2)
plt.hist(rvList, bins=rvRange, density = True, rwidth=0.5, align="left")
plt.xlabel('Random Variable')
plt.ylabel('Probability')
plt.show()

plt.show()

print("Expected value is     : " , expectedValue)
print("Variance is           : " , variance)
print("Standart Deviation is : " , standartDeviation)

"""**Action 2: Modify the model to simulate the sum of three dice. Now your RV (X) is the sum of three dice, and run the simulation 1000 times. Show the histogram (PMF) of X, and indicate the expected value, standard deviation, and the variance of X on the screen. You will repeat this several times and observe the results.**

In this code, program execution determines how many times the code will be executed. In this experiment that we roll three dice 1000 times and sum them up, we get expected value generally between 10.3-10.7 while the expected value for sum of rolled three dice is 10.5 theorotically. I executed the code many times and I observed that generally, 10 and 11 have the highest probability and always middle part of the graph is higher while the probability decreases as we go far away from middle.
"""

import matplotlib.pyplot as plt
import random
import statistics 



programExecution = 1
rvList = []
for j in range(0, programExecution):
    rollNumber = 1000
    for i in range(0,rollNumber):
         x = random.randint(1,6)
         y = random.randint(1,6)
         z = random.randint(1,6)
         rvList.append(x + y + z)

standartDeviation = statistics.stdev(rvList)
variance = statistics.variance(rvList)
expectedValue = statistics.mean(rvList)


rvRange = range(min(rvList), max(rvList) + 2)
plt.hist(rvList, bins=rvRange, density = True, rwidth=0.5, align="left")
plt.xlabel('Random Variable')
plt.ylabel('Probability')
plt.show()

plt.show()

print("Expected value is     : " , expectedValue)
print("Variance is           : " , variance)
print("Standart Deviation is : " , standartDeviation)

"""**Action 3: Take a coin with P(heads) = p. Flip the coin N times and let X be the random variable that indicates how many times the coin comes up heads. Now simulate this RV for different p’s (0.5 and 0.2) and N’s, and report the expected value and the variance of X in a table.**

This code calculates how many heads do we get in 10, 100, 1000, 10000 and 100000 tosses for a fair coin and an unfair coin that has 0.2 probability of getting head. With this code, we can see that as experiment size increases, experimental expected value is getting closer to the theoretical expected value.
"""

import matplotlib.pyplot as plt
import random
import statistics 
import plotly.graph_objects as go

experimentList = [10, 100, 1000, 10000, 100000]

#Probability of head is 0.5

theoEVList = []
expEVList = []
varList = []
sdList = []
for i in range(0, len(experimentList)):
  data = []
  for j in range(0, experimentList[i]):
     x = random.randint(0, 1)
     data.append(x)
  theoEVList.append(experimentList[i] / 2)
  expEVList.append(statistics.mean(data) * experimentList[i])
  varList.append("%.2f" % (statistics.variance(data) * experimentList[i]))
  sdList.append("%.2f" % (statistics.stdev(data) * experimentList[i]))
  
print("When probability of getting head is 0.5")
fig = go.Figure(data=[go.Table(header=dict(values=['Number of Tossses', 'Theoretical Expected Value', 'Experimental Expected Value', 'Variance', "Standart Deviation"]),
                 cells=dict(values=[experimentList, theoEVList, expEVList, varList, sdList]))
                     ])
fig.show()

#Probability of head is 0.2
population = [0, 1]
weights = [0.8, 0.2]
theoEVList = []
expEVList = []
varList = []
sdList = []
for i in range(0, len(experimentList)):
  data = []
  for j in range(0, experimentList[i]):
     x = random.randint(0, 4)
     if x != 0:
      data.append(0)
     else:
      data.append(1)
   
  theoEVList.append(experimentList[i] / 5)
  expEVList.append(statistics.mean(data) * experimentList[i])
  varList.append("%.2f" % (statistics.variance(data) * experimentList[i]))
  sdList.append("%.2f" % (statistics.stdev(data) * experimentList[i]))
  
print("When probability of getting head is 0.2")
fig = go.Figure(data=[go.Table(header=dict(values=['Number of Tossses', 'Theoretical Expected Value', 'Experimental Expected Value', 'Variance', "Standart Deviation"]),
                 cells=dict(values=[experimentList, theoEVList, expEVList, varList, sdList]))
                     ])
fig.show()

"""**Action 4: Simulate flipping a coin until it comes up heads. Let X be the number of flips it takes for the coin to come up heads. Now simulate this RV for different p’s (0.5 and 0.2), and report the expected value and the variance of X in a table.**

In this code, we flip a coin until we get first head. Experiment results variess a lot but I get heads at most on 6th flip when I run the code several times for a fair coin. For other coiin which has 0.2 probability to get heads, I am generally be able to get heads on 4-7th flips which is close to the expected value.
"""

import matplotlib.pyplot as plt
import random
import statistics 
import plotly.graph_objects as go


flag = True
#Probability of head is 0.5

rvList1 = []
tossCount1 = 0
while flag:

     x = random.randint(0, 1)
     rvList1.append(x)
     tossCount1 += 1
     if x == 0:
        flag = False
  
flag = True  
rvList2 = []
tossCount2 = 0
while flag:
     x = random.randint(0, 4)
     rvList2.append(x)
     tossCount2 += 1
     if x == 0:
        flag = False
  
     
print("When probability of getting head is 0.5")
fig = go.Figure(data=[go.Table(header=dict(values=['Probability of getting head', 'Theoretical Expected Value', 'Experimental Expected Value', 'Variance', "Standart Deviation"]),
                 cells=dict(values=[["0.5", "0.2"], [(1/0.5), (1/0.2)], [tossCount1, tossCount2] , [("%.2f" % (statistics.variance(rvList1))), ("%.2f" % (statistics.variance(rvList2)))], [("%.2f" % (statistics.stdev(rvList1))), ("%.2f" % (statistics.stdev(rvList2)))]]))
                     ])
fig.show()